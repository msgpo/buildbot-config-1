# -*- python -*-
# ex: set filetype=python:

import json
import buildbot
import logging
import os.path

from buildbot.plugins import util, steps, worker, schedulers
from buildbot.www.hooks.github import GitHubEventHandler
from buildbot.steps.worker import CompositeStepMixin
from twisted.internet import defer
from twisted.python import log

###############################################################################
# Global Functions
# 
# Global functions that make the rest off the config easier
###############################################################################
def application_id_is_valid(possible_id):
    return len(possible_id.split('.')) >= 3

def buildname_to_id(buildname):
    if "//" in buildname:
        return buildname.split("//", 1)[0]

    return buildname.split("/", 1)[0]

def strip_dot_git(module):
    if module.endswith(".git"):
        module = module[:-4]
    
    return module

def get_arch_builder_name(arch):
    return "build-" + arch

def hide_on_success(results, s):
    return results == buildbot.process.results.SUCCESS

def hide_on_skipped(results, s):
    return results == buildbot.process.results.SKIPPED

def hide_on_success_or_skipped(results, s):
    return results == buildbot.process.results.SUCCESS or results == buildbot.process.results.SKIPPED

def inherit_properties(propnames):
    result = {}
    for name in propnames:
        result[name] = util.Property(name)
    return result

def get_id_from_git_url(url):
    s = url.rsplit('/', 1);
    base = s[0]
    git_module = s[1]

    if git_module.endswith(".git"):
        id = module[:-4]
    else:
        id = git_module

    return id

def shell_arg_optional(commands):
    return util.ShellArg(logfile='stdio', command=commands)

def shell_arg(commands):
    return util.ShellArg(logfile='stdio', haltOnFailure=True, command=commands)

###############################################################################
# Global Configs
###############################################################################
config_file = open('config.json', 'r')
config = json.loads(config_file.read())

def getConfig(name, default=""):
    return config.get(name, default)

def getConfigv(name, default=[]):
    return config.get(name, default)

BUILDBOT_TITLE = getConfig('buildbot-title', 'flatpak builder')
BUILDBOT_TITLE_URL = getConfig('buildbot-title-url', None)
BUILDBOT_PORT = getConfig('buildbot-port', 8010)
BUILDBOT_URL = getConfig('buildbot-url', 'http://localhost:8010/')
BUILDBOT_DB = getConfig('buildbot-db', 'sqlite:///state.sqlite')
BUILDBOT_WORKER_PORT = getConfig('buildbot-worker-port', 9989)

BUILDBOT_AUTH_ADMIN = getConfig('buildbot-auth-admin', None)
BUILDBOT_AUTH_ADMIN_ROLE = getConfig('buildbot-auth-admin-role', "admins")

BUILDBOT_HTTP_PORT = getConfig('buildbot-http-port', 8010)

BUILDBOT_NUMBER_MASTER_WORKERS = getConfig('buildbot-number-master-workers', 4)

GITHUB_AUTH_CLIENT = getConfig('github-auth-client', None)
GITHUB_AUTH_SECRET = getConfig('github-auth-secret', None)
GITHUB_CHANGE_SECRET = getConfig('github-change-secret', None)
GITHUB_ORGANIZATION_NAME = getConfig('github-organization-name', None)

GITLAB_AUTH_URL = getConfig('gitlab-auth-url', None)
GITLAB_AUTH_CLIENT = getConfig('gitlab-auth-client', None)
GITLAB_AUTH_SECRET = getConfig('gitlab-auth-secret', None)
GITLAB_CHANGE_SECRET = getConfig('gitlab-change-secret', None)
GITlab_ORGANIZATION_NAME = getConfig('gitlab-organization-name', None)

# These should never be None
REPO_UPSTREAM_REPO = getConfig('repo-upstream-repo', "")
REPO_UPSTREAM_SOURCES_URI = getConfig('repo-upstream-sources-uri', os.path.join (REPO_UPSTREAM_REPO, "sources" ))

REPO_DEFAULT_BRANCH = getConfig('repo-default-branch', 'stable')

REPO_DEP_REPO = getConfig('repo-dep-repo', 'flathub')
REPO_DEP_REPO_URL = getConfig('repo-dep-repo-url', 'https://dl.flathub.org/repo/flathub.flatpakrepo')

REPO_GPG_HOMEDIR = getConfig('repo-gpg-homedir', None)
REPO_GPG_KEY = getConfig('repo-gpg-key', None)
REPO_GPG_FILE_NAME = getConfig('repo-gpg-file-name', 'repo.gpg')
REPO_GPG_FILE_SOURCE = getConfig('repo-gpg-file-source', None)
REPO_GPG_FILE_SOURCE_SHA256SUM = getConfig('repo-gpg-file-source-sha256sum', None)

REPO_CONFIG_FILE = getConfig('repo-config-file', 'config.json')

###############################################################################
# Build Master Configs
###############################################################################
c = BuildmasterConfig = {}

c['buildbotNetUsageData'] = None
c['title'] = BUILDBOT_TITLE
c['titleURL'] = BUILDBOT_TITLE_URL
c['buildbotURL'] = BUILDBOT_URL
c['protocols'] = {
    'pb': {
        'port': BUILDBOT_WORKER_PORT
    }
}

c['workers'] = []
c['change_source'] = []
c['schedulers'] = []
c['builders'] = []

c['www'] = dict(
    port = BUILDBOT_PORT,
    plugins = dict(
        waterfall_view = {},
        console_view = {},
        grid_view = {}
    ),
    change_hook_dialects = {
        'github': {},
        'gitlab': {}
    },
    authz = None
)

c['db'] = {
    'db_url': BUILDBOT_DB
}

###############################################################################
# Authentication
# https://docs.buildbot.net/latest/manual/cfg-www.html#web-authentication
# auth: the authentication details
# authz: the way we authenticate
# 
# We first attempt to authenticate with simple username and password, 
# however, if GitHub authentication is an option we do that. Then GitLab is 
# an option, but GitHub and GitLab shouldn't be used together
###############################################################################
auth = None
authz = None
authz_allow_rules_role = "admins"
authz_role_matchers = []

# First we try auth with admin username and password
if BUILDBOT_AUTH_ADMIN != None and not BUILDBOT_AUTH_ADMIN:
    auth = util.UserPasswordAuth({BUILDBOT_AUTH_ADMIN['username']: BUILDBOT_AUTH_ADMIN['password']})
    authz_allow_rules_role = BUILDBOT_AUTH_ADMIN_ROLE
    authz_role_matchers.append(util.RolesFromUsername(admins=["admin"]))

# If we are connected to GitHub we use GitHub user accounts as auth
if GITHUB_AUTH_CLIENT is not None and GITHUB_AUTH_SECRET is not None:
    auth = util.GitHubAuth(GITHUB_AUTH_CLIENT, GITHUB_AUTH_SECRET)
    authz_allow_rules_role = GITHUB_ORGANIZATION_NAME
    authz_role_matchers.append(util.RolesFromGroups())

# If we are connected to GitLab we use GitHub user accounts as auth
if GITLAB_AUTH_URL is not None and GITLAB_AUTH_CLIENT is not None and GITLAB_AUTH_SECRET is not None:
    auth = util.GitLabAuth(GITLAB_AUTH_URL, GITLAB_AUTH_CLIENT, GITLAB_AUTH_SECRET)
    authz_allow_rules_role = GITlab_ORGANIZATION_NAME
    authz_role_matchers.append(util.RolesFromGroups())

# Authentication method and how we validate those that should connect
authz = util.Authz(
    allowRules=[
        util.AnyControlEndpointMatcher(role=authz_allow_rules_role)
    ],
    roleMatchers=authz_role_matchers
)

# Authentication user & passwords
c['www']['auth'] = auth

# Method to authenticate
c['www']['authz'] = authz

###############################################################################
# Workers
# 
# workers.json: A JSON file with all the workers with configs for each worker
###############################################################################
build_arches = []
build_workers = {}

build_sdk_workers = []
build_app_workers = []

local_workers = []

worker_file = open('workers.json', 'r')
worker_config = json.loads(worker_file.read ())

for w in worker_config.keys():
    wc = worker_config[w]
    max_builds = 1
    
    if 'update-repo' in wc:
        max_builds = 2
        
    if 'max-builds' in wc:
        max_builds = wc['max-builds']

    if 'roles' in wc:
        if "sdk" in wc['roles']:
            build_sdk_workers.append(w)
            
        if "app" in wc['roles']:
            build_app_workers.append(w)
    
    if "arches" in wc:
        for arch in wc['arches']:
            if not arch in build_arches:
                build_arches.append(arch)
                
            if not arch in build_workers:
                build_workers[arch] = []
        
            build_workers[arch].append(w)
    
    c['workers'].append(
        worker.Worker(w, wc['password'], max_builds=max_builds)
    )


for i in range(1, BUILDBOT_NUMBER_MASTER_WORKERS + 1):
    name = 'master-worker-%d' % i
    c['workers'].append (worker.LocalWorker(name))
    local_workers.append(name)

###############################################################################
# Change Source
# 
# We don't really use the change_source config, instead we use the 
# change_hook_dialects in the www config. This listens for request sent from 
# GitHub or GitLab.
#
# GitHub API types:
# https://developer.github.com/v3/activity/events/types/
###############################################################################
class GitHubChangeHandler(GitHubEventHandler):

    def handle_push(self, payload, event):
        changes = []
        
        repository_url       = payload["repository"]["html_url"]  # https://github.com/winepak/org.winepak.Example
        repository_git_url   = payload["repository"]["git_url"]   # git://github.com/winepak/org.winepak.Example
        repository_ssh_url   = payload["repository"]["ssh_url"]   # git://github.com/winepak/org.winepak.Example
        repository_clone_url = payload["repository"]["clone_url"] # https://github.com/winepak/org.winepak.Example.git
        repository_name      = payload["repository"]["name"]      # org.winepak.Example
        repository_fullname  = payload["repository"]["full_name"] # winepak/org.winepak.Example
        project              = repository_name.replace("/", "-")  # winepak-org.winepak.Example
        
        # Push Specific
        ref                  = payload["ref"]
        branch               = ref[len("refs/heads/"):]
        
        log.msg("Processing GitHub push")
        
        if not ref.startswith("refs/heads/"):
            log.msg("Ignoring request, refname `{}' is not a branch".format(ref))
            return None
        
        if payload.get("deleted"):
            log.msg("Ignoring request, branch `{}' was deleted".format(branch))
            return None
        
        change = {
            "repository": repository_url,
            "branch": branch,
            "project": project,
            "author": payload["sender"]["login"],
            "comments": "GitHub Push Request",
            "category": "pull-request"
        }
        
        changes.append(change)

        return changes, "git"

    def handle_pull_request(self, payload, event):
        changes = []
        
        repository_url       = payload["repository"]["html_url"]  # https://github.com/winepak/org.winepak.Example
        repository_git_url   = payload["repository"]["git_url"]   # git://github.com/winepak/org.winepak.Example
        repository_ssh_url   = payload["repository"]["ssh_url"]   # git://github.com/winepak/org.winepak.Example
        repository_clone_url = payload["repository"]["clone_url"] # https://github.com/winepak/org.winepak.Example.git
        repository_name      = payload["repository"]["name"]      # org.winepak.Example
        repository_fullname  = payload["repository"]["full_name"] # winepak/org.winepak.Example
        project              = repository_name.replace("/", "-")  # winepak-org.winepak.Example
        
        # Pull Request Specific
        issue_number         = payload["number"]
        branch               = "refs/pull/{}/head".format(issue_number)

        log.msg("Processing GitHub pull request #{}".format(issue_number))
        
        # Only track the following actioins
        # We capture "push" with self.handle_push() and we only care about the first create
        action = payload.get('action')
        if action not in ('opened', 'reopened', 'synchronize'):
            log.msg("Ignoring request, PR #{} `{}' not an action".format(issue_number, action))
            return None
        
        # Pull Request Specific
        author_association = payload["pull_request"]["author_association"]
        
        if author_association not in ["COLLABORATOR", "CONTRIBUTOR", "MEMBER", "OWNER"]:
            log.msg("Ignoring request, user with association `{}' is not a trusted member".format(author_association))
            return None
        
        change = {
            "repository": repository_url,
            "branch": branch,
            "project": project,
            "author": payload["sender"]["login"],
            "comments": "GitHub Pull Request #{} test build\n".format(issue_number),
            "category": "pull-request"
        }
        
        changes.append(change)

        return changes, "git"
    
    def handle_issue_comment(self, payload, event):
        changes = []
        
        repository_url       = payload["repository"]["html_url"]  # https://github.com/winepak/org.winepak.Example
        repository_git_url   = payload["repository"]["git_url"]   # git://github.com/winepak/org.winepak.Example
        repository_ssh_url   = payload["repository"]["ssh_url"]   # git://github.com/winepak/org.winepak.Example
        repository_clone_url = payload["repository"]["clone_url"] # https://github.com/winepak/org.winepak.Example.git
        repository_name      = payload["repository"]["name"]      # org.winepak.Example
        repository_fullname  = payload["repository"]["full_name"] # winepak/org.winepak.Example
        project              = repository_name.replace("/", "-")  # winepak-org.winepak.Example
        
        # Comment Specific
        body                 = payload["comment"]["body"]
        issue_number         = payload["issue"]["number"]
        issue_url            = payload["comment"]["issue_url"]
        branch               = "refs/pull/{}/head".format(issue_number)

        log.msg("Processing GitHub comment #{}".format(issue_number))
        
        if not "pull_request" in payload["issue"]:
            log.msg("Ignoring request, non-pull comment")
            return None
        
        if payload.get("deleted"):
            log.msg("Ignoring request, comment was deleted".format(branch))
            return None
        
        # Comment Specific
        offset = body.find("bot, build");
        if offset == -1:
            return None

        build_id = None
        rest = body[offset+len("bot, build"):]
        lines = rest.splitlines()
        if len(lines) > 0:
            words = lines[0].split()
            if len(words) > 0:
                build_id = words[0]

        log.msg("Detected build test request in %s PR %d (id %s)" % (repository_url, issue_number, build_id))
        
        author_association = payload["comment"]["author_association"]
        
        if author_association not in ["COLLABORATOR", "CONTRIBUTOR", "MEMBER", "OWNER"]:
            log.msg("Ignoring request, user with association `{}' is not a trusted member".format(author_association))
            return None
        
        change = {
            "repository": repository_url,
            "branch": branch,
            "project": project,
            "author": payload["sender"]["login"],
            "comments": "GitHub Pull Request #{} test build\n".format(issue_number),
            "category": "bot-build"
        }
        
        changes.append(change)

        return changes, "git"

if GITHUB_CHANGE_SECRET is not None:
    c["www"]["change_hook_dialects"]["github"] = {
        "class": GitHubChangeHandler,
        "secret": GITHUB_CHANGE_SECRET,
        "strict": True
    }

if GITLAB_CHANGE_SECRET is not None:
    c["www"]["change_hook_dialects"]["gitlab"] = {
        "secret": GITLAB_CHANGE_SECRET
    }

###############################################################################
# Properties Step
###############################################################################
class RepoPropertiesStep(steps.BuildStep, CompositeStepMixin):
    def __init__(self, **kwargs):
        steps.BuildStep.__init__(self, **kwargs)
        self.logEnviron = False

    @defer.inlineCallbacks
    def run(self):
        props = self.build.properties

        repo_config = {}
        arches = []
        
        # This builds number
        buildnumber = props.getProperty('buildnumber')
        
        # Pull repo config
        content = yield self.getFileContentFromWorker(REPO_CONFIG_FILE)
        
        if content != None:
            repo_config = json.loads(content)

        # Insure no empty config
        if not repo_config:
            repo_config["empty"] = True
        
        # Git properties
        git_repository = props.getProperty('repository')
        git_branch = props.getProperty('branch')
        git_subject = props.getProperty('git-subject')
        git_revision = props.getProperty('got_revision')

        # Repo properties
        repo_id = get_id_from_git_url(git_repository)
        repo_url = git_repository

        # Get manifest name
        repo_manifest = "%s.yaml" % repo_id
        has_yaml = yield self.pathExists("build/" + repo_manifest)
        if not has_yaml:
            repo_manifest = "%s.yml" % repo_id
            has_yml = yield self.pathExists("build/" + repo_manifest)
            if not has_yml:
                repo_manifest = "%s.json" % repo_id
                has_json = yield self.pathExists("build/" + repo_manifest)
                if not has_json:
                    defer.returnValue(buildbot.process.results.FAILURE)
        
        # Default branchs
        # A bit backwards but if it's in master then we consider it stable,
        # any other branch would be testing.
        #if git_branch == "master":
        #    repo_branch = "stable"
        #else:
        #    repo_branch = "edge"
        repo_branch = "stable"
        
        repo_default_branch = REPO_DEFAULT_BRANCH
        
        # Arches
        arches = set(build_arches)

        if "only-arches" in repo_config:
            arches = arches & set(repo_config["only-arches"])

        if "skip-arches" in repo_config:
            arches = arches - set(repo_config["skip-arches"])
        
        repo_arches = list(arches)
        
        # Git information
        repo_subject = "%s (%s)" % (git_subject, git_revision[:8])
        
        # Properties list
        repo_properties = {
            "repo-id": repo_id,
            "repo-url": repo_url,
            "repo-manifest": repo_manifest,
            "repo-branch": repo_branch,
            "repo-default-branch": repo_default_branch,
            "repo-arches": repo_arches,
            "repo-config": repo_config,
            "repo-subject": repo_subject,
            "repo-artifact-dir": "builds/{}".format(buildnumber)
        }

        for key, value in repo_properties.items():
            self.setProperty(key, value, self.name, runtime=True)

        defer.returnValue(buildbot.process.results.SUCCESS)

###############################################################################
# Schedulers
###############################################################################
c['schedulers'].append(
    schedulers.ForceScheduler(
        name="force",
        buttonName="Force Rebuild",
        label="Force a rebuild",
        builderNames=["build-master"],

        codebases=[
            util.CodebaseParameter(
                "",
                label="Main repository",
                branch=util.StringParameter(name="branch", label="branch:", default=""),
                revision=util.FixedParameter(name="revision", default=""),
                repository=util.FixedParameter(name="repository", label="repo uri:", default=""),
                project=util.FixedParameter(name="project", default="")
            )
        ],
        reason=util.StringParameter(name="reason",
                                    label="reason:",
                                    required=True, default="force build", size=80),
        properties=[
            util.StringParameter(name="buildname",
                                 label="Buildname:",
                                 required=False),
            util.StringParameter(name="force-arches",
                                 label="Arches: (comma separated)",
                                 required=False)
        ]
    )
)

c['schedulers'].append(
    schedulers.AnyBranchScheduler(
        name="checkin",
        treeStableTimer=10,
        builderNames=["build-master"]
    )
)

@util.renderer
def computeBuildArches(props):
    builders = []
    for arch in props.getProperty("repo-arches", []):
        builders.append(get_arch_builder_name(arch))
        
    return builders

c['schedulers'].append(
    schedulers.Triggerable(
        name="build-all-platforms",
        builderNames=computeBuildArches
    )
)

###############################################################################
# Customer Renderer
###############################################################################
@util.renderer
def computeMasterBaseDir(props):
    return props.master.basedir

###############################################################################
# Properties
#
# These properties are set in the main build and inherited to sub-builds
###############################################################################
inherited_properties = [
    "repo-id",
    "repo-url",
    "repo-manifest",
    "repo-branch",
    "repo-default-branch",
    "repo-config",
    "repo-subject",
    "repo-arches",
    "repo-issue-url",
    "repo-artifact-dir"
]

###############################################################################
# Build Factories
###############################################################################
flatpak_builder_global_args = []

if REPO_GPG_KEY:
    flatpak_builder_global_args.append ('--gpg-sign=' + REPO_GPG_KEY)

if REPO_GPG_HOMEDIR:
    flatpak_builder_global_args.append ('--gpg-homedir=' + REPO_GPG_HOMEDIR)

# Build SDK
build_sdk_factory = util.BuildFactory()
build_sdk_factory.addSteps([
    steps.ShellCommand(name="flatpak remote-add --if-no-exists flathub https://http://dl.flathub.org/repo/flathub.flatpakrepo",
        command=[
            "flatpak",
            "remote-add",
            "--if-no-exists",
            "flathub",
            "https://dl.flathub.org/repo/flathub.flatpakrepo"
        ],
        haltOnFailure=True,
        description=""
    )
])

# Build Application
build_app_factory = util.BuildFactory()
build_app_factory.addSteps([
    steps.Git(
        name="checkout manifest",
        description="",
        haltOnFailure=True,
        logEnviron=False,
        repourl=util.Property('repository'),
        mode='incremental',
        branch='master',
        submodules=True
    ),
    steps.SetPropertyFromCommand(
        name="Getting git status for subject",
        description="",
        haltOnFailure=True,
        logEnviron=False,
        command="git show --format=%s -s $(git rev-list --no-merges -n 1 HEAD)",
        property="git-subject"
    ),
    RepoPropertiesStep(
        name="Set repo properties",
        description="",
        haltOnFailure=True,
    ),
    steps.Trigger(
        name='Build all platforms',
        description="",
        haltOnFailure=True,
        schedulerNames=['build-all-platforms'],
        updateSourceStamp=True,
        waitForFinish=True,
        set_properties=inherit_properties(inherited_properties)
    )
])

# Build manifest
build_manifest_factory = util.BuildFactory()
build_manifest_factory.addSteps([
    steps.Git(
        name="Checkout manifest",
        description="",
        haltOnFailure=True,
        logEnviron=False,
        repourl=util.Property('repository'),
        mode='incremental',
        branch='master',
        submodules=True
    ),
    steps.ShellSequence(
        name='Clean-up working directory',
        description="Clean out any previous leftover mounts",
        haltOnFailure=True,
        logEnviron=False,
        commands=[
            shell_arg('for i in .flatpak-builder/rofiles/rofiles-*/; do fusermount -u $i; done || true')
        ]
    ),
    steps.FileDownload(
        name='Downloading public key',
        description="",
        haltOnFailure=True,
        mastersrc=REPO_GPG_FILE_NAME,
        workerdest=REPO_GPG_FILE_NAME
    ),
    steps.ShellSequence(
        name='Init OSTree repo',
        description="",
        haltOnFailure=True,
        logEnviron=False,
        commands=[
            shell_arg(['ostree', '--repo=repo', '--mode=archive-z2', 'init']),
        ]
    ),
    steps.ShellCommand(
        name="Add remote flatpak dependency repo",
        description="",
        haltOnFailure=True,
        command=[
            "flatpak",
            "remote-add",
            "--user",
            "--if-not-exists",
            "--gpg-import",
            REPO_GPG_FILE_NAME,
            REPO_DEP_REPO,
            REPO_DEP_REPO_URL
        ]
    ),
    steps.ShellCommand(
        name="Build manifest (flatpak-builder)",
        description="",
        haltOnFailure=True,
        usePTY=True,
        command=[
            "flatpak-builder",
            "-v",
            "--sandbox",
            "--delete-build-dirs",
            "--user",
            "--install-deps-from", REPO_DEP_REPO,
            "--ccache",
            "--force-clean",
            "--repo", "repo",
            "--default-branch", util.Property('repo-default-branch'),
            "--subject", util.Property('repo-subject'),
            util.Property('repo-extra-flatpak-builder-args'), # eg. --arch x86_64
            
            #"--mirror-screenshots-url", REPO_SCREENSHOT_URL, # https://dl.winepak.org/repo/screenshots
            #"--extra-sources-url=", REPO_EXRTA_SOURCES_URL,
            #util.Interpolate('--extra-sources=%(prop:builddir)s/../downloads'),
            
            "builddir",
            util.Interpolate('%(prop:repo-manifest)s')
        ] + flatpak_builder_global_args
    ),
    steps.ShellCommand(
        name='Generate static deltas',
        description="",
        haltOnFailure=True,
        logEnviron=False,
        timeout=10000,
        warnOnFailure=True,
        command=util.Interpolate('flatpak build-update-repo --generate-static-deltas repo')
        #command=util.Interpolate('flatpak build-update-repo --generate-static-deltas --static-delta-ignore-ref=*.Debug  --static-delta-ignore-ref=*.Sources repo') # Need flatpak 1.3.0 >
    ),
    steps.ShellCommand(
        name='Check for AppStream xml',
        description="",
        doStepIf=lambda step: not step.build.getProperty('repo-config', {}).get("skip-appstream-check"),
        haltOnFailure=True,
        logEnviron=False,
        command=util.Interpolate('stat builddir/*/share/app-info/xmls/%(prop:repo-id)s.xml.gz')
    ),
    steps.ShellCommand(
        name='Check for correct id in AppStream xml',
        description="",
        doStepIf=lambda step: not step.build.getProperty('repo-config', {}).get("skip-appstream-check"),
        haltOnFailure=True,
        logEnviron=False,
        command=util.Interpolate('zgrep "<id>%(prop:repo-id)s\\(\\.\\w\\+\\)*\\(.desktop\\)\\?</id>" builddir/*/share/app-info/xmls/%(prop:repo-id)s.xml.gz')
    ),
    steps.ShellCommand(
        name='Check that the right branch was built',
        description="",
        haltOnFailure=True,
        logEnviron=False,
        command=util.Interpolate('test ! -d repo/refs/heads/app -o -f repo/refs/heads/app/%(prop:repo-id)s/%(prop:repo-arch)s/%(prop:repo-branch)s')
    ),
    steps.ShellSequence(
        name='Download previous revision',
        description="Copy the previous repo commit to a local repo so we can use it as the parent",
        logEnviron=False,
        haltOnFailure=True,
        commands=[
            # We use bare-user mode so that the deltas work
            shell_arg(['ostree', '--repo=remote-repo', '--mode=bare-user', 'init']),
            shell_arg(['ostree', 'remote', 'add', '--if-not-exists', '--repo=remote-repo', '--gpg-import', REPO_GPG_FILE_NAME, 'origin', REPO_UPSTREAM_REPO]),
            shell_arg('for ref in `ostree --repo=repo refs | grep -v appstream`; do echo "$ref"; ostree --repo=remote-repo pull --mirror --disable-fsync origin "$ref" || true; done')
        ]
    ),
    steps.ShellSequence(
        name='Rebase build on previous revision',
        description="",
        haltOnFailure=True,
        logEnviron=False,
        commands=[
            # Merge the two into a new repo
            shell_arg(['ostree', '--repo=merged-repo', 'init', '--mode=archive-z2']),
            shell_arg(['ostree', 'pull-local', '--disable-fsync', '--repo=merged-repo', 'remote-repo']),
            shell_arg(['rm', '-rf', 'remote-repo']),
            shell_arg(['flatpak', 'build-commit-from', '--disable-fsync', '--src-repo=repo', 'merged-repo']),
            # Switch merged-repo to 'repo', which is later packed up as the build result
            shell_arg(['rm', '-rf', 'repo']),
            shell_arg(['mv', 'merged-repo', 'repo'])
        ]
    ),
    steps.ShellSequence(
        name='Post-build work',
        description="",
        haltOnFailure=True,
        logEnviron=False,
        commands=[
            # Remove unreferenced objects to avoid uploading them
            shell_arg(['ostree', 'prune', '--repo=repo', '--refs-only', '--depth=0']),
            # Ensure directories are there
            shell_arg(['mkdir', '-p', 'builddir/screenshots']),
            # Copy screenshots
            shell_arg(['cp', '-r', 'builddir/screenshots', 'repo/'])
        ]
    ),
    steps.ShellCommand(
        name='Packaging build for upload',
        description="",
        haltOnFailure=True,
        logEnviron=False,
        command=[
            'tar',
            'cf',
            'repo.tar',
            'repo'
        ]
    ),
    steps.FileUpload(
        name='Uploading artifacts to master',
        description="",
        haltOnFailure=True,
        workersrc='repo.tar',
        masterdest=util.Interpolate('%(prop:repo-artifact-dir)s/%(prop:repo-arch)s-repo.tar'),
        blocksize=512*1024
    )
])

###############################################################################
# Builders
###############################################################################
c['builders'].append(
    util.BuilderConfig(
        name='build-master',
        collapseRequests=True,
        workernames=local_workers,
        factory=build_app_factory
    )
)
for arch in build_arches:
    builder_name = get_arch_builder_name(arch)

    extra_fb_args = [
        "--arch", arch
    ]
    
    if arch == 'x86_64':
        extra_fb_args.append("--bundle-sources")

    c['builders'].append(
        util.BuilderConfig(
            name=builder_name,
            workernames=build_workers[arch],
            properties={
                'repo-arch': arch,
                'repo-extra-flatpak-builder-args': extra_fb_args
            },
            factory=build_manifest_factory
        )
    )
